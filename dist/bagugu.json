[
  {
    "id": "java-jvm-jvm-内存区域",
    "category": "Java/JVM",
    "title": "JVM 内存区域",
    "concept": "JVM 运行时数据区的划分",
    "explanation": "线程私有：程序计数器、虚拟机栈、本地方法栈。\n线程共享：堆（存放对象实例）、方法区/元空间（存放类信息、常量）。\nJDK 1.8 后方法区由永久代改为元空间（Metaspace），使用本地内存。",
    "question": "说一下 JVM 的内存区域划分",
    "keyPoints": [
      "程序计数器：当前线程执行的字节码行号",
      "虚拟机栈：存放栈帧（局部变量表、操作数栈）",
      "堆：对象实例和数组，GC 主要区域",
      "方法区/元空间：类信息、常量池、静态变量"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "把永久代和元空间混为一谈",
        "right": "说清楚 JDK 版本差异"
      }
    ],
    "followUp": [
      {
        "q": "哪些区域会发生 OOM？",
        "a": "堆（最常见）、栈（递归过深）、元空间（动态生成类过多）"
      }
    ]
  },
  {
    "id": "java-jvm-gc-算法",
    "category": "Java/JVM",
    "title": "GC 算法",
    "concept": "自动回收不再使用的对象，释放内存",
    "explanation": "判断对象存活：引用计数（有循环引用问题）、可达性分析（GC Roots）。\n回收算法：标记-清除、标记-复制、标记-整理。\n分代收集：新生代用复制算法，老年代用标记-整理。",
    "question": "说一下 JVM 的垃圾回收机制",
    "keyPoints": [
      "可达性分析：从 GC Roots 出发，不可达的对象被回收",
      "GC Roots：栈帧引用、静态变量、常量、JNI 引用",
      "新生代：Eden + S0 + S1，Minor GC",
      "老年代：Full GC，STW 时间长"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "只说\"引用计数\"",
        "right": "Java 用可达性分析，引用计数有循环引用问题"
      }
    ],
    "followUp": [
      {
        "q": "什么是 STW？如何减少 STW 时间？",
        "a": "Stop The World，所有线程暂停。使用 G1、ZGC 等低延迟收集器"
      }
    ]
  },
  {
    "id": "java-jvm-常用收集器",
    "category": "Java/JVM",
    "title": "常用收集器",
    "concept": "执行垃圾回收的具体实现",
    "explanation": "串行：Serial、Serial Old（单线程，STW）。\n并行：Parallel Scavenge、Parallel Old（多线程，吞吐量优先）。\n并发：CMS、G1、ZGC（低延迟，减少 STW）。",
    "question": "说一下你了解的垃圾收集器",
    "keyPoints": [
      "CMS：并发标记清除，低延迟，有碎片",
      "G1：分 Region，可预测停顿时间",
      "ZGC：JDK 11+，TB 级堆，STW < 10ms",
      "Shenandoah：类似 ZGC，Red Hat 出品"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "只说名字，不说特点",
        "right": "结合场景：吞吐量 → Parallel，延迟 → G1/ZGC"
      }
    ],
    "followUp": [
      {
        "q": "JDK 8/11/17 默认收集器？",
        "a": "JDK 8 是 Parallel，JDK 9+ 是 G1"
      }
    ]
  },
  {
    "id": "java-jvm-类加载过程",
    "category": "Java/JVM",
    "title": "类加载过程",
    "concept": "将 .class 文件加载到 JVM 内存的过程",
    "explanation": "加载 → 验证 → 准备 → 解析 → 初始化。\n双亲委派：先委托父加载器加载，父加载器无法加载才自己加载。\n打破双亲委派：SPI、OSGi、Tomcat 等场景。",
    "question": "说一下类加载过程和双亲委派机制",
    "keyPoints": [
      "加载：读取字节码，生成 Class 对象",
      "验证：校验字节码格式",
      "准备：为静态变量分配内存，赋默认值",
      "初始化：执行 <clinit>，赋初始值"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "漏掉\"准备阶段赋默认值\"",
        "right": "准备阶段 int 默认 0，初始化阶段才赋代码中的值"
      }
    ],
    "followUp": [
      {
        "q": "为什么要双亲委派？",
        "a": "安全（防止篡改核心类）+ 避免重复加载"
      }
    ]
  },
  {
    "id": "java-并发编程-synchronized-原理",
    "category": "Java/并发编程",
    "title": "synchronized 原理",
    "concept": "Java 内置的同步机制，可修饰方法或代码块",
    "explanation": "synchronized 基于 Monitor（监视器锁）实现。\nJDK 1.6 后引入锁升级优化：偏向锁 → 轻量级锁 → 重量级锁。\n对象头的 Mark Word 存储锁状态信息。",
    "question": "说一下 synchronized 的实现原理和锁升级过程",
    "keyPoints": [
      "底层：monitorenter/monitorexit 指令",
      "锁升级：无锁 → 偏向锁 → 轻量级锁（CAS自旋）→ 重量级锁",
      "偏向锁：记录线程 ID，同一线程无需 CAS",
      "轻量级锁：CAS 自旋，竞争不激烈时高效"
    ],
    "compare": {
      "vs": "ReentrantLock",
      "diff": "后者可中断、可超时、可公平"
    },
    "traps": [
      {
        "wrong": "说 synchronized 很重，性能差",
        "right": "JDK 1.6 后优化很大，轻量级场景性能接近 CAS"
      }
    ],
    "followUp": [
      {
        "q": "什么情况下锁会升级？",
        "a": "偏向锁遇到竞争升级为轻量级锁，自旋超过阈值升级为重量级锁"
      }
    ]
  },
  {
    "id": "java-并发编程-volatile-原理",
    "category": "Java/并发编程",
    "title": "volatile 原理",
    "concept": "保证变量的可见性和禁止指令重排序",
    "explanation": "volatile 通过内存屏障实现：写操作后加 StoreLoad 屏障，读操作前加 LoadLoad 屏障。\n可见性：写入主内存，其他线程缓存失效。\n有序性：禁止编译器和 CPU 重排序。",
    "question": "volatile 能保证什么？不能保证什么？",
    "keyPoints": [
      "保证可见性：修改立即刷新到主内存",
      "保证有序性：禁止指令重排",
      "不保证原子性：i++ 不是原子操作"
    ],
    "compare": {
      "vs": "synchronized",
      "diff": "volatile 更轻量，但不保证原子性"
    },
    "traps": [
      {
        "wrong": "认为 volatile 可以替代锁",
        "right": "volatile 适用于一写多读，或状态标志位"
      }
    ],
    "followUp": [
      {
        "q": "双重检查锁为什么需要 volatile？",
        "a": "防止指令重排：分配内存 → 初始化 → 赋值引用 可能被重排"
      }
    ]
  },
  {
    "id": "java-并发编程-threadpoolexecutor",
    "category": "Java/并发编程",
    "title": "ThreadPoolExecutor",
    "concept": "管理和复用线程的执行器，避免频繁创建销毁线程",
    "explanation": "核心参数：corePoolSize、maxPoolSize、keepAliveTime、workQueue、handler。\n执行流程：核心线程 → 队列 → 最大线程 → 拒绝策略。\n常用实现：FixedThreadPool、CachedThreadPool、ScheduledThreadPool。",
    "question": "说一下线程池的核心参数和执行流程",
    "keyPoints": [
      "corePoolSize：核心线程数，即使空闲也不回收",
      "maxPoolSize：最大线程数",
      "workQueue：阻塞队列，存放等待任务",
      "流程：任务 → 核心线程 → 队列 → 非核心线程 → 拒绝"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "直接用 Executors 创建（OOM 风险）",
        "right": "手动创建 ThreadPoolExecutor，控制队列大小"
      }
    ],
    "followUp": [
      {
        "q": "四种拒绝策略？",
        "a": "AbortPolicy（抛异常）、CallerRunsPolicy（调用者执行）、DiscardPolicy（丢弃）、DiscardOldestPolicy（丢弃最老）"
      }
    ]
  },
  {
    "id": "java-并发编程-abstractqueuedsynchronizer",
    "category": "Java/并发编程",
    "title": "AbstractQueuedSynchronizer",
    "concept": "Java 并发包的基础框架，ReentrantLock、Semaphore 等都基于它",
    "explanation": "AQS 维护一个 volatile int state 表示同步状态，和一个 FIFO 双向队列存放等待线程。\n子类通过重写 tryAcquire/tryRelease 实现自定义同步器。\n支持独占模式和共享模式。",
    "question": "说一下 AQS 的原理",
    "keyPoints": [
      "state：同步状态，volatile 修饰",
      "CLH 队列：双向链表，存放等待线程",
      "获取锁：CAS 修改 state，失败则入队等待",
      "释放锁：修改 state，唤醒后继节点"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "只说 CAS",
        "right": "CAS + 队列 + park/unpark"
      }
    ],
    "followUp": [
      {
        "q": "ReentrantLock 的公平锁和非公平锁区别？",
        "a": "公平锁先检查队列，非公平锁直接 CAS 竞争"
      }
    ]
  },
  {
    "id": "java-集合框架-hashmap-底层实现",
    "category": "Java/集合框架",
    "title": "HashMap 底层实现",
    "concept": "基于哈希表的 Map 实现，提供 O(1) 的存取性能",
    "explanation": "HashMap 在 JDK 1.8 中使用数组 + 链表 + 红黑树的结构。\n数组存储 Node 节点，当发生哈希冲突时，使用链表或红黑树解决。\n当链表长度超过 8 且数组长度超过 64 时，链表转换为红黑树。",
    "question": "说一下 HashMap 的底层实现原理",
    "keyPoints": [
      "结构：数组 + 链表 + 红黑树（JDK 1.8+）",
      "扰动函数：hash = (h = key.hashCode()) ^ (h >>> 16)",
      "定位：index = (n - 1) & hash",
      "扩容：默认负载因子 0.75，扩容为原来的 2 倍"
    ],
    "compare": {
      "vs": "Hashtable",
      "diff": "HashMap 非线程安全，允许 null 键值"
    },
    "traps": [
      {
        "wrong": "说成数组 + 链表就结束了",
        "right": "要提到红黑树优化，以及转换条件（链表长度 > 8 且数组长度 > 64）"
      }
    ],
    "followUp": [
      {
        "q": "为什么用红黑树不用 AVL 树？",
        "a": "红黑树插入删除性能更好，AVL 太严格，频繁调整"
      }
    ]
  },
  {
    "id": "java-集合框架-两种-list-对比",
    "category": "Java/集合框架",
    "title": "两种 List 对比",
    "concept": "ArrayList 基于动态数组，LinkedList 基于双向链表",
    "explanation": "ArrayList 随机访问快 O(1)，但插入删除需要移动元素 O(n)。\nLinkedList 插入删除快 O(1)，但随机访问需要遍历 O(n)。\n实际开发中 ArrayList 使用更多，因为 CPU 缓存友好。",
    "question": "ArrayList 和 LinkedList 的区别？什么时候用哪个？",
    "keyPoints": [
      "底层：数组 vs 双向链表",
      "随机访问：ArrayList O(1) vs LinkedList O(n)",
      "插入删除：ArrayList O(n) vs LinkedList O(1)（已知节点）",
      "内存：ArrayList 连续，LinkedList 需要额外指针空间"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "说 LinkedList 插入删除一定快",
        "right": "LinkedList 要先找到位置，找的过程是 O(n)"
      }
    ],
    "followUp": [
      {
        "q": "ArrayList 扩容机制？",
        "a": "默认初始容量 10，扩容为 1.5 倍，使用 Arrays.copyOf"
      }
    ]
  },
  {
    "id": "java-集合框架-线程安全的-hashmap",
    "category": "Java/集合框架",
    "title": "线程安全的 HashMap",
    "concept": "线程安全的哈希表实现，JDK 1.8 使用 CAS + synchronized",
    "explanation": "JDK 1.7 使用分段锁 Segment，JDK 1.8 改为 CAS + synchronized。\n1.8 中锁的粒度更细，只锁住链表头或红黑树根节点。\n使用 volatile 保证可见性，sizeCtl 控制初始化和扩容。",
    "question": "ConcurrentHashMap 如何保证线程安全？",
    "keyPoints": [
      "JDK 1.7：Segment 分段锁，继承 ReentrantLock",
      "JDK 1.8：CAS + synchronized，锁住桶头节点",
      "扩容：多线程协作扩容，transferIndex 分配任务",
      "size()：使用 baseCount + CounterCell 数组累加"
    ],
    "compare": {
      "vs": "Collections.synchronizedMap",
      "diff": "后者全表锁，性能差"
    },
    "traps": [
      {
        "wrong": "只说 CAS 或只说 synchronized",
        "right": "两者结合：CAS 无竞争时高效，有竞争时 synchronized"
      }
    ],
    "followUp": [
      {
        "q": "put 操作的完整流程？",
        "a": "计算 hash → CAS 插入空桶 → synchronized 处理冲突 → 检查扩容"
      }
    ]
  },
  {
    "id": "ios-uikit核心-responder-chain",
    "category": "iOS/UIKit核心",
    "title": "Responder Chain",
    "concept": "iOS 中处理触摸事件的链式传递机制",
    "explanation": "当用户触摸屏幕时，系统需要找到应该响应这个触摸的视图。\n这个过程分两步：先从上往下找到被点击的视图（Hit Testing），\n再从下往上找到能处理事件的对象（Responder Chain）。",
    "question": "解释 iOS 的 Responder Chain 机制",
    "keyPoints": [
      "Hit Testing：从根视图向下递归查找，使用 hitTest(_:with:) 方法",
      "Action 传递：从 hit 视图向上查找响应者",
      "顺序：View → ViewController → Window → AppDelegate"
    ],
    "compare": {
      "vs": "Android 事件分发",
      "diff": "iOS 先下后上，Android 是隧道+冒泡"
    },
    "traps": [
      {
        "wrong": "只说 hit testing，忘了 action 传递",
        "right": "两部分都要说：先下（找视图）→ 再上（找响应者）"
      }
    ],
    "followUp": [
      {
        "q": "如何让父视图响应而不是子视图？",
        "a": "子视图设置 isUserInteractionEnabled = false 或重写 hitTest 返回 nil"
      }
    ]
  },
  {
    "id": "ios-uikit核心-view-lifecycle",
    "category": "iOS/UIKit核心",
    "title": "View Lifecycle",
    "concept": "UIViewController 从创建到销毁的一系列回调方法",
    "explanation": "当 ViewController 被加载、显示、隐藏、销毁时，系统会调用一系列生命周期方法。\n理解这些方法的调用顺序对于正确初始化和清理资源至关重要。",
    "question": "说一下 UIViewController 的生命周期方法",
    "keyPoints": [
      "loadView → viewDidLoad（只调用一次）",
      "viewWillAppear → viewDidAppear（每次显示都调用）",
      "viewWillDisappear → viewDidDisappear（每次消失都调用）"
    ],
    "compare": {
      "vs": "viewDidLoad",
      "diff": "viewWillAppear 每次显示都调用，viewDidLoad 只一次"
    },
    "traps": [
      {
        "wrong": "在 viewDidLoad 里做依赖屏幕尺寸的布局",
        "right": "布局相关操作放 viewDidLayoutSubviews"
      }
    ],
    "followUp": [
      {
        "q": "viewDidLoad 和 viewWillAppear 应该分别做什么？",
        "a": "viewDidLoad 做一次性初始化，viewWillAppear 做每次显示前的刷新（如数据更新）"
      }
    ]
  },
  {
    "id": "ios-性能优化-retain-cycle",
    "category": "iOS/性能优化",
    "title": "Retain Cycle",
    "concept": "两个或多个对象相互强引用导致无法释放的内存泄漏",
    "explanation": "当对象 A 强引用对象 B，对象 B 又强引用对象 A 时，\n即使外部不再引用它们，它们的引用计数也不会变为 0，导致内存泄漏。",
    "question": "什么是 Retain Cycle？如何避免？",
    "keyPoints": [
      "定义：相互强引用导致的内存泄漏",
      "常见场景：closure 捕获 self、delegate 强引用",
      "解决方案：[weak self]、[unowned self]、weak delegate"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "所有 closure 都用 weak self（有时不需要）",
        "right": "只在 closure 可能被 self 持有时才用 weak"
      }
    ],
    "followUp": [
      {
        "q": "weak 和 unowned 的区别？",
        "a": "weak 是可选类型可为 nil，unowned 非可选假设永不为 nil，访问已释放对象会崩溃"
      }
    ]
  },
  {
    "id": "ios-性能优化-内存泄漏调试",
    "category": "iOS/性能优化",
    "title": "内存泄漏调试",
    "concept": "使用工具检测和定位内存泄漏问题",
    "explanation": "Xcode 提供多种工具来检测内存问题：Instruments 的 Leaks 和 Allocations，\nMemory Graph Debugger 可视化对象关系，MetricKit 收集生产环境数据。",
    "question": "如何调试内存泄漏？",
    "keyPoints": [
      "Instruments → Leaks：检测泄漏的对象",
      "Memory Graph Debugger：可视化引用关系，找循环引用",
      "MetricKit：生产环境监控内存峰值"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "只依赖 Leaks 工具（不能检测所有问题）",
        "right": "结合 Memory Graph 看引用关系更直观"
      }
    ],
    "followUp": []
  },
  {
    "id": "系统设计-app架构-mvvm",
    "category": "系统设计/App架构",
    "title": "MVVM",
    "concept": "Model-View-ViewModel 架构模式，实现视图与业务逻辑分离",
    "explanation": "View 负责 UI 展示，ViewModel 负责业务逻辑和数据转换，\nModel 负责数据模型。View 通过数据绑定监听 ViewModel 的变化。",
    "question": "解释 MVVM 架构，为什么选择它？",
    "keyPoints": [
      "View：UI 展示，不包含业务逻辑",
      "ViewModel：业务逻辑、数据转换、可测试",
      "Model：数据模型",
      "优点：可测试性高、关注点分离、适合 SwiftUI/Combine"
    ],
    "compare": {
      "vs": "MVC",
      "diff": "ViewModel 替代 Controller，更易测试，避免 Massive VC"
    },
    "traps": [
      {
        "wrong": "ViewModel 直接持有 View（应该反过来）",
        "right": "View 持有 ViewModel，ViewModel 不知道 View 的存在"
      }
    ],
    "followUp": [
      {
        "q": "MVVM 的缺点是什么？",
        "a": "数据绑定复杂、调试困难、小项目可能过度设计、学习曲线陡峭"
      }
    ]
  },
  {
    "id": "系统设计-app架构-依赖注入",
    "category": "系统设计/App架构",
    "title": "依赖注入",
    "concept": "将对象的依赖从内部创建改为外部传入",
    "explanation": "不在类内部直接创建依赖对象，而是通过构造函数、属性或方法参数传入。\n这样可以轻松替换依赖（如用 Mock 测试），提高代码的可测试性和灵活性。",
    "question": "什么是依赖注入？为什么要用？",
    "keyPoints": [
      "定义：依赖从外部传入而非内部创建",
      "方式：构造函数注入、属性注入、方法注入",
      "好处：可测试（注入 Mock）、解耦、灵活"
    ],
    "compare": null,
    "traps": [
      {
        "wrong": "在 ViewModel 里直接创建 NetworkService()",
        "right": "通过构造函数传入 protocol，方便测试时注入 Mock"
      }
    ],
    "followUp": []
  }
]